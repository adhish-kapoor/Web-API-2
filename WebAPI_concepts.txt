# Action Results in Web API 2
====================================
A Web API controller action can return any of the following:

1. void
2. HttpResponseMessage
3. IHttpActionResult
4. Some other type

Depending on which of these is returned, Web API uses a different mechanism to create the HTTP response.

TABLE 1
Return type              | 	  How Web API creates the response
void	                        Return empty 204 (No Content)
HttpResponseMessage	          Convert directly to an HTTP response message.
IHttpActionResult	            Call ExecuteAsync to create an HttpResponseMessage, then convert to an HTTP response message.
Other type	                  Write the serialized return value into the response body; return 200 (OK).

=> void
If the return type is void, Web API simply returns an empty HTTP response with status code 204 (No Content).

Example controller:
public class ValuesController : ApiController
{
    public void Post()
    {
    }
}

HTTP response:
HTTP/1.1 204 No Content
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 02:13:26 GMT

=> HttpResponseMessage
If the action returns an HttpResponseMessage, Web API converts the return value directly into an HTTP response message, 
using the properties of the HttpResponseMessage object to populate the response.

This option gives you a lot of control over the response message. 
For example, the following controller action sets the Cache-Control header.

public class ValuesController : ApiController
{
    public HttpResponseMessage Get()
    {
        HttpResponseMessage response = Request.CreateResponse(HttpStatusCode.OK, "value");
        response.Content = new StringContent("hello", Encoding.Unicode);
        response.Headers.CacheControl = new CacheControlHeaderValue()
        {
            MaxAge = TimeSpan.FromMinutes(20)
        };
        return response;
    } 
}

Response:
HTTP/1.1 200 OK
Cache-Control: max-age=1200
Content-Length: 10
Content-Type: text/plain; charset=utf-16
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 08:53:35 GMT

hello

If you pass a domain model to the CreateResponse method, Web API uses a media formatter to write the serialized model into the response body.
public HttpResponseMessage Get()
{
    // Get a list of products from a database.
    IEnumerable<Product> products = GetProductsFromDB();

    // Write the list to the response body.
    HttpResponseMessage response = Request.CreateResponse(HttpStatusCode.OK, products);
    return response;
}

Web API uses the Accept header in the request to choose the formatter.

=> IHttpActionResult
The IHttpActionResult interface was introduced in Web API 2. Essentially, it defines an HttpResponseMessage factory. 
Here are some advantages of using the IHttpActionResult interface:

1. Simplifies unit testing your controllers.
2. Moves common logic for creating HTTP responses into separate classes.
3. Makes the intent of the controller action clearer, by hiding the low-level details of constructing the response.

IHttpActionResult contains a single method, ExecuteAsync, which asynchronously creates an HttpResponseMessage instance.
public interface IHttpActionResult
{
    Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken);
}

If a controller action returns an IHttpActionResult, Web API calls the ExecuteAsync method to create an HttpResponseMessage. 
Then it converts the HttpResponseMessage into an HTTP response message.

Here is a simple implementation of IHttpActionResult that creates a plain text response:

public class TextResult : IHttpActionResult
{
    string _value;
    HttpRequestMessage _request;

    public TextResult(string value, HttpRequestMessage request)
    {
        _value = value;
        _request = request;
    }
    public Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
    {
        var response = new HttpResponseMessage()
        {
            Content = new StringContent(_value),
            RequestMessage = _request
        };
        return Task.FromResult(response);
    }
}

Example controller action:
public class ValuesController : ApiController
{
    public IHttpActionResult Get()
    {
        return new TextResult("hello", Request);
    }
}

Response:
HTTP/1.1 200 OK
Content-Length: 5
Content-Type: text/plain; charset=utf-8
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 08:53:35 GMT

hello

More often, you use the IHttpActionResult implementations defined in the System.Web.Http.Results namespace. 
The ApiController class defines helper methods that return these built-in action results.

In the following example, if the request does not match an existing product ID, the controller calls ApiController.NotFound to create a 404 (Not Found) response. 
Otherwise, the controller calls ApiController.OK, which creates a 200 (OK) response that contains the product.

public IHttpActionResult Get (int id)
{
    Product product = _repository.Get (id);
    if (product == null)
    {
        return NotFound(); // Returns a NotFoundResult
    }
    return Ok(product);  // Returns an OkNegotiatedContentResult
}

=> Other Return Types
For all other return types, Web API uses a media formatter to serialize the return value. 
Web API writes the serialized value into the response body. The response status code is 200 (OK).

public class ProductsController : ApiController
{
    public IEnumerable<Product> Get()
    {
        return GetAllProductsFromDB();
    }
}

A disadvantage of this approach is that you cannot directly return an error code, such as 404. 
However, you can throw an HttpResponseException for error codes.

Web API uses the Accept header in the request to choose the formatter. For more information, see Content Negotiation.
Example request
GET http://localhost/api/products HTTP/1.1
User-Agent: Fiddler
Host: localhost:24127
Accept: application/json

Example response
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 08:53:35 GMT
Content-Length: 56

[{"Id":1,"Name":"Yo-yo","Category":"Toys","Price":6.95}]


# Routing in ASP.NET Web API
======================================

=> Routing Tables
In ASP.NET Web API, a controller is a class that handles HTTP requests. The public methods of the controller are called action methods or simply actions.
When the Web API framework receives a request, it routes the request to an action.

To determine which action to invoke, the framework uses a routing table. The Visual Studio project template for Web API creates a default route:
This route is defined in the WebApiConfig.cs file, which is placed in the App_Start directory:
routes.MapHttpRoute(
    name: "API Default",
    routeTemplate: "api/{controller}/{id}",
    defaults: new { id = RouteParameter.Optional }
);

Each entry in the routing table contains a route template. The default route template for Web API is "api/{controller}/{id}". 
In this template, "api" is a literal path segment, and {controller} and {id} are placeholder variables.

When the Web API framework receives an HTTP request, it tries to match the URI against one of the route templates in the routing table. 
If no route matches, the client receives a 404 error. For example, the following URIs match the default route:

/api/contacts
/api/contacts/1
/api/products/gizmo1

However, the following URI does not match, because it lacks the "api" segment:
/contacts/1

The reason for using "api" in the route is to avoid collisions with ASP.NET MVC routing. 
That way, you can have "/contacts" go to an MVC controller, and "/api/contacts" go to a Web API controller.

Once a matching route is found, Web API selects the controller and the action:

1. To find the controller, Web API adds "Controller" to the value of the {controller} variable.
2. To find the action, Web API looks at the HTTP verb, and then looks for an action whose name begins with that HTTP verb name. 
For example, with a GET request, Web API looks for an action prefixed with "Get", such as "GetContact" or "GetAllContacts". 
This convention applies only to GET, POST, PUT, DELETE, HEAD, OPTIONS, and PATCH verbs. 
You can enable other HTTP verbs by using attributes on your controller. We'll see an example of that later.
3. Other placeholder variables in the route template, such as {id}, are mapped to action parameters.

public class ProductsController : ApiController
{
    public IEnumerable<Product> GetAllProducts() { }
    public Product GetProductById(int id) { }
    public HttpResponseMessage DeleteProduct(int id){ }
}

Here are some possible HTTP requests, along with the action that gets invoked for each:

TABLE 1
HTTP Verb	URI Path	        Action	            Parameter
GET	        api/products	    GetAllProducts	    (none)
GET	        api/products/4	    GetProductById	    4
DELETE	    api/products/4	    DeleteProduct	    4
POST	    api/products	    (no match)	
Notice that the {id} segment of the URI, if present, is mapped to the id parameter of the action. 
In this example, the controller defines two GET methods, one with an id parameter and one with no parameters.

Also, note that the POST request will fail, because the controller does not define a "Post..." method.

=> Routing Variations
Instead of using the naming convention for HTTP verbs, you can explicitly specify the HTTP verb for an action by decorating the action method with one of the following attributes:

[HttpGet]
[HttpPut]
[HttpPost]
[HttpDelete]
[HttpHead]
[HttpOptions]
[HttpPatch]

In the following example, the FindProduct method is mapped to GET requests:

public class ProductsController : ApiController
{
    [HttpGet]
    public Product FindProduct(id) {}
}

To allow multiple HTTP verbs for an action, or to allow HTTP verbs other than GET, PUT, POST, DELETE, HEAD, OPTIONS, and PATCH, 
use the [AcceptVerbs] attribute, which takes a list of HTTP verbs.

public class ProductsController : ApiController
{
    [AcceptVerbs("GET", "HEAD")]
    public Product FindProduct(id) { }

    // WebDAV method
    [AcceptVerbs("MKCOL")]
    public void MakeCollection() { }
}

=> Routing by Action Name
With the default routing template, Web API uses the HTTP verb to select the action. 
However, you can also create a route where the action name is included in the URI:

routes.MapHttpRoute(
    name: "ActionApi",
    routeTemplate: "api/{controller}/{action}/{id}",
    defaults: new { id = RouteParameter.Optional }
);

In this route template, the {action} parameter names the action method on the controller. 
With this style of routing, use attributes to specify the allowed HTTP verbs. 
For example, suppose your controller has the following method:

public class ProductsController : ApiController
{
    [HttpGet]
    public string Details(int id){}
}

In this case, a GET request for "api/products/details/1" would map to the Details method. 
This style of routing is similar to ASP.NET MVC, and may be appropriate for an RPC-style API.

You can override the action name by using the [ActionName] attribute. 
In the following example, there are two actions that map to "api/products/thumbnail/id. One supports GET and the other supports POST:

public class ProductsController : ApiController
{
    [HttpGet]
    [ActionName("Thumbnail")]
    public HttpResponseMessage GetThumbnailImage(int id);

    [HttpPost]
    [ActionName("Thumbnail")]
    public void AddThumbnailImage(int id);
}

=> Non-Actions
To prevent a method from getting invoked as an action, use the [NonAction] attribute. 
This signals to the framework that the method is not an action, even if it would otherwise match the routing rules.

// Not an action method.
[NonAction]  
public string GetPrivateData() { ... }

# Routing and Action Selection in ASP.NET Web API
=======================================================

Routing has three main phases:

1. Matching the URI to a route template.
2. Selecting a controller.
3. Selecting an action.

=> Route Templates
A route template looks similar to a URI path, but it can have placeholder values, indicated with curly braces:
"api/{controller}/public/{category}/{id}"

When you create a route, you can provide default values for some or all of the placeholders:
defaults: new { category = "all" }

You can also provide constraints, which restrict how a URI segment can match a placeholder:
constraints: new { id = @"\d+" }   // Only matches if "id" is one or more digits.

The framework tries to match the segments in the URI path to the template. Literals in the template must match exactly. 
A placeholder matches any value, unless you specify constraints. The framework does not match other parts of the URI, such as the host name or the query parameters. 
The framework selects the first route in the route table that matches the URI.

There are two special placeholders: "{controller}" and "{action}".

"{controller}" provides the name of the controller.
"{action}" provides the name of the action. In Web API, the usual convention is to omit "{action}".

=> Defaults
If you provide defaults, the route will match a URI that is missing those segments. For example:
routes.MapHttpRoute(
    name: "DefaultApi",
    routeTemplate: "api/{controller}/{category}",
    defaults: new { category = "all" }
);

The URIs http://localhost/api/products/all and http://localhost/api/products match the preceding route.
In the latter URI, the missing {category} segment is assigned the default value all.

=> Route Dictionary
If the framework finds a match for a URI, it creates a dictionary that contains the value for each placeholder. 
The keys are the placeholder names, not including the curly braces. 
The values are taken from the URI path or from the defaults. 
The dictionary is stored in the IHttpRouteData object.

A default can have the special value RouteParameter.Optional. 
If a placeholder gets assigned this value, the value is not added to the route dictionary. For example:
routes.MapHttpRoute(
    name: "DefaultApi",
    routeTemplate: "api/{controller}/{category}/{id}",
    defaults: new { category = "all", id = RouteParameter.Optional }
);

For the URI path "api/products", the route dictionary will contain:
controller: "products"
category: "all"

For "api/products/toys/123", however, the route dictionary will contain:
controller: "products"
category: "toys"
id: "123"

The defaults can also include a value that does not appear anywhere in the route template. 
If the route matches, that value is stored in the dictionary. For example:
routes.MapHttpRoute(
    name: "Root",
    routeTemplate: "api/root/{id}",
    defaults: new { controller = "customers", id = RouteParameter.Optional }
);

If the URI path is "api/root/8", the dictionary will contain two values:
controller: "customers"
id: "8"

=> Selecting a Controller
Controller selection is handled by the IHttpControllerSelector.SelectController method. 
This method takes an HttpRequestMessage instance and returns an HttpControllerDescriptor. 
The default implementation is provided by the DefaultHttpControllerSelector class. This class uses a straightforward algorithm:

1. Look in the route dictionary for the key "controller".
2. Take the value for this key and append the string "Controller" to get the controller type name.
3. Look for a Web API controller with this type name.

For example, if the route dictionary contains the key-value pair "controller" = "products", then the controller type is "ProductsController". 
If there is no matching type, or multiple matches, the framework returns an error to the client.

=> Action Selection
After selecting the controller, the framework selects the action by calling the IHttpActionSelector.SelectAction method. 
This method takes an HttpControllerContext and returns an HttpActionDescriptor.
The default implementation is provided by the ApiControllerActionSelector class.


# Attribute Routing in ASP.NET Web API 2
==============================================

=> Why Attribute Routing?
One advantage of convention-based routing is that templates are defined in a single place, and the routing rules are applied consistently across all controllers. 
Unfortunately, convention-based routing makes it hard to support certain URI patterns that are common in RESTful APIs.

/customers/1/orders

This type of URI is difficult to create using convention-based routing. 
Although it can be done, the results don't scale well if you have many controllers or resource types.

With attribute routing, it's trivial to define a route for this URI. You simply add an attribute to the controller action:
[Route("customers/{customerId}/orders")]
public IEnumerable<Order> GetOrdersByCustomer(int customerId) { ... }

Here are some other patterns that attribute routing makes easy.

API versioning
In this example, "/api/v1/products" would be routed to a different controller than "/api/v2/products".

/api/v1/products /api/v2/products

Overloaded URI segments
In this example, "1" is an order number, but "pending" maps to a collection.

/orders/1 /orders/pending

Multiple parameter types
In this example, "1" is an order number, but "2013/06/16" specifies a date.

/orders/1 /orders/2013/06/16

=> Enabling Attribute Routing
To enable attribute routing, call MapHttpAttributeRoutes during configuration. 
This extension method is defined in the System.Web.Http.HttpConfigurationExtensions class.

using System.Web.Http;

namespace WebApplication
{
    public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            // Web API routes
            config.MapHttpAttributeRoutes();

            // Other Web API configuration not shown.
        }
    }
}

Attribute routing can be combined with convention-based routing. To define convention-based routes, call the MapHttpRoute method.
public static class WebApiConfig
{
    public static void Register(HttpConfiguration config)
    {
        // Attribute routing.
        config.MapHttpAttributeRoutes();

        // Convention-based routing.
        config.Routes.MapHttpRoute(
            name: "DefaultApi",
            routeTemplate: "api/{controller}/{id}",
            defaults: new { id = RouteParameter.Optional }
        );
    }
}

=> Note: Migrating From Web API 1
Prior to Web API 2, the Web API project templates generated code like this:
protected void Application_Start()
{
    // WARNING - Not compatible with attribute routing.
    WebApiConfig.Register(GlobalConfiguration.Configuration);
}

If attribute routing is enabled, this code will throw an exception. 
If you upgrade an existing Web API project to use attribute routing, make sure to update this configuration code to the following:

protected void Application_Start()
{
    // Pass a delegate to the Configure method.
    GlobalConfiguration.Configure(WebApiConfig.Register);
}

