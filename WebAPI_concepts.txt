# Action Results in Web API 2
====================================
A Web API controller action can return any of the following:

1. void
2. HttpResponseMessage
3. IHttpActionResult
4. Some other type

Depending on which of these is returned, Web API uses a different mechanism to create the HTTP response.

TABLE 1
Return type              | 	  How Web API creates the response
void	                        Return empty 204 (No Content)
HttpResponseMessage	          Convert directly to an HTTP response message.
IHttpActionResult	            Call ExecuteAsync to create an HttpResponseMessage, then convert to an HTTP response message.
Other type	                  Write the serialized return value into the response body; return 200 (OK).

=> void
If the return type is void, Web API simply returns an empty HTTP response with status code 204 (No Content).

Example controller:
public class ValuesController : ApiController
{
    public void Post()
    {
    }
}

HTTP response:
HTTP/1.1 204 No Content
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 02:13:26 GMT

=> HttpResponseMessage
If the action returns an HttpResponseMessage, Web API converts the return value directly into an HTTP response message, 
using the properties of the HttpResponseMessage object to populate the response.

This option gives you a lot of control over the response message. 
For example, the following controller action sets the Cache-Control header.

public class ValuesController : ApiController
{
    public HttpResponseMessage Get()
    {
        HttpResponseMessage response = Request.CreateResponse(HttpStatusCode.OK, "value");
        response.Content = new StringContent("hello", Encoding.Unicode);
        response.Headers.CacheControl = new CacheControlHeaderValue()
        {
            MaxAge = TimeSpan.FromMinutes(20)
        };
        return response;
    } 
}

Response:
HTTP/1.1 200 OK
Cache-Control: max-age=1200
Content-Length: 10
Content-Type: text/plain; charset=utf-16
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 08:53:35 GMT

hello

If you pass a domain model to the CreateResponse method, Web API uses a media formatter to write the serialized model into the response body.
public HttpResponseMessage Get()
{
    // Get a list of products from a database.
    IEnumerable<Product> products = GetProductsFromDB();

    // Write the list to the response body.
    HttpResponseMessage response = Request.CreateResponse(HttpStatusCode.OK, products);
    return response;
}

Web API uses the Accept header in the request to choose the formatter.

=> IHttpActionResult
The IHttpActionResult interface was introduced in Web API 2. Essentially, it defines an HttpResponseMessage factory. 
Here are some advantages of using the IHttpActionResult interface:

1. Simplifies unit testing your controllers.
2. Moves common logic for creating HTTP responses into separate classes.
3. Makes the intent of the controller action clearer, by hiding the low-level details of constructing the response.

IHttpActionResult contains a single method, ExecuteAsync, which asynchronously creates an HttpResponseMessage instance.
public interface IHttpActionResult
{
    Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken);
}

If a controller action returns an IHttpActionResult, Web API calls the ExecuteAsync method to create an HttpResponseMessage. 
Then it converts the HttpResponseMessage into an HTTP response message.

Here is a simple implementation of IHttpActionResult that creates a plain text response:

public class TextResult : IHttpActionResult
{
    string _value;
    HttpRequestMessage _request;

    public TextResult(string value, HttpRequestMessage request)
    {
        _value = value;
        _request = request;
    }
    public Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
    {
        var response = new HttpResponseMessage()
        {
            Content = new StringContent(_value),
            RequestMessage = _request
        };
        return Task.FromResult(response);
    }
}

Example controller action:
public class ValuesController : ApiController
{
    public IHttpActionResult Get()
    {
        return new TextResult("hello", Request);
    }
}

Response:
HTTP/1.1 200 OK
Content-Length: 5
Content-Type: text/plain; charset=utf-8
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 08:53:35 GMT

hello

More often, you use the IHttpActionResult implementations defined in the System.Web.Http.Results namespace. 
The ApiController class defines helper methods that return these built-in action results.

In the following example, if the request does not match an existing product ID, the controller calls ApiController.NotFound to create a 404 (Not Found) response. 
Otherwise, the controller calls ApiController.OK, which creates a 200 (OK) response that contains the product.

public IHttpActionResult Get (int id)
{
    Product product = _repository.Get (id);
    if (product == null)
    {
        return NotFound(); // Returns a NotFoundResult
    }
    return Ok(product);  // Returns an OkNegotiatedContentResult
}

=> Other Return Types
For all other return types, Web API uses a media formatter to serialize the return value. 
Web API writes the serialized value into the response body. The response status code is 200 (OK).

public class ProductsController : ApiController
{
    public IEnumerable<Product> Get()
    {
        return GetAllProductsFromDB();
    }
}

A disadvantage of this approach is that you cannot directly return an error code, such as 404. 
However, you can throw an HttpResponseException for error codes.

Web API uses the Accept header in the request to choose the formatter. For more information, see Content Negotiation.
Example request
GET http://localhost/api/products HTTP/1.1
User-Agent: Fiddler
Host: localhost:24127
Accept: application/json

Example response
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Server: Microsoft-IIS/8.0
Date: Mon, 27 Jan 2014 08:53:35 GMT
Content-Length: 56

[{"Id":1,"Name":"Yo-yo","Category":"Toys","Price":6.95}]


# Routing in ASP.NET Web API
======================================

=> Routing Tables
In ASP.NET Web API, a controller is a class that handles HTTP requests. The public methods of the controller are called action methods or simply actions.
When the Web API framework receives a request, it routes the request to an action.

To determine which action to invoke, the framework uses a routing table. The Visual Studio project template for Web API creates a default route:
This route is defined in the WebApiConfig.cs file, which is placed in the App_Start directory:
routes.MapHttpRoute(
    name: "API Default",
    routeTemplate: "api/{controller}/{id}",
    defaults: new { id = RouteParameter.Optional }
);

Each entry in the routing table contains a route template. The default route template for Web API is "api/{controller}/{id}". 
In this template, "api" is a literal path segment, and {controller} and {id} are placeholder variables.

When the Web API framework receives an HTTP request, it tries to match the URI against one of the route templates in the routing table. 
If no route matches, the client receives a 404 error. For example, the following URIs match the default route:

/api/contacts
/api/contacts/1
/api/products/gizmo1

However, the following URI does not match, because it lacks the "api" segment:
/contacts/1

The reason for using "api" in the route is to avoid collisions with ASP.NET MVC routing. 
That way, you can have "/contacts" go to an MVC controller, and "/api/contacts" go to a Web API controller.

Once a matching route is found, Web API selects the controller and the action:

1. To find the controller, Web API adds "Controller" to the value of the {controller} variable.
2. To find the action, Web API looks at the HTTP verb, and then looks for an action whose name begins with that HTTP verb name. 
For example, with a GET request, Web API looks for an action prefixed with "Get", such as "GetContact" or "GetAllContacts". 
This convention applies only to GET, POST, PUT, DELETE, HEAD, OPTIONS, and PATCH verbs. 
You can enable other HTTP verbs by using attributes on your controller. We'll see an example of that later.
3. Other placeholder variables in the route template, such as {id}, are mapped to action parameters.

public class ProductsController : ApiController
{
    public IEnumerable<Product> GetAllProducts() { }
    public Product GetProductById(int id) { }
    public HttpResponseMessage DeleteProduct(int id){ }
}

Here are some possible HTTP requests, along with the action that gets invoked for each:

TABLE 1
HTTP Verb	URI Path	        Action	            Parameter
GET	        api/products	    GetAllProducts	    (none)
GET	        api/products/4	    GetProductById	    4
DELETE	    api/products/4	    DeleteProduct	    4
POST	    api/products	    (no match)	
Notice that the {id} segment of the URI, if present, is mapped to the id parameter of the action. 
In this example, the controller defines two GET methods, one with an id parameter and one with no parameters.

Also, note that the POST request will fail, because the controller does not define a "Post..." method.

=> Routing Variations
Instead of using the naming convention for HTTP verbs, you can explicitly specify the HTTP verb for an action by decorating the action method with one of the following attributes:

[HttpGet]
[HttpPut]
[HttpPost]
[HttpDelete]
[HttpHead]
[HttpOptions]
[HttpPatch]

In the following example, the FindProduct method is mapped to GET requests:

public class ProductsController : ApiController
{
    [HttpGet]
    public Product FindProduct(id) {}
}

To allow multiple HTTP verbs for an action, or to allow HTTP verbs other than GET, PUT, POST, DELETE, HEAD, OPTIONS, and PATCH, 
use the [AcceptVerbs] attribute, which takes a list of HTTP verbs.

public class ProductsController : ApiController
{
    [AcceptVerbs("GET", "HEAD")]
    public Product FindProduct(id) { }

    // WebDAV method
    [AcceptVerbs("MKCOL")]
    public void MakeCollection() { }
}

=> Routing by Action Name
With the default routing template, Web API uses the HTTP verb to select the action. 
However, you can also create a route where the action name is included in the URI:

routes.MapHttpRoute(
    name: "ActionApi",
    routeTemplate: "api/{controller}/{action}/{id}",
    defaults: new { id = RouteParameter.Optional }
);

In this route template, the {action} parameter names the action method on the controller. 
With this style of routing, use attributes to specify the allowed HTTP verbs. 
For example, suppose your controller has the following method:

public class ProductsController : ApiController
{
    [HttpGet]
    public string Details(int id){}
}

In this case, a GET request for "api/products/details/1" would map to the Details method. 
This style of routing is similar to ASP.NET MVC, and may be appropriate for an RPC-style API.

You can override the action name by using the [ActionName] attribute. 
In the following example, there are two actions that map to "api/products/thumbnail/id. One supports GET and the other supports POST:

public class ProductsController : ApiController
{
    [HttpGet]
    [ActionName("Thumbnail")]
    public HttpResponseMessage GetThumbnailImage(int id);

    [HttpPost]
    [ActionName("Thumbnail")]
    public void AddThumbnailImage(int id);
}

=> Non-Actions
To prevent a method from getting invoked as an action, use the [NonAction] attribute. 
This signals to the framework that the method is not an action, even if it would otherwise match the routing rules.

// Not an action method.
[NonAction]  
public string GetPrivateData() { ... }

